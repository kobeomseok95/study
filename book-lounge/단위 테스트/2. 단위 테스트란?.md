```toc
```

# 2. 1 단위 테스트의 정의
---
- 작은 코드 조각을 검증한다.
- 빠르게 수행한다.
- 격리된 방식으로 처리하는 자동화된 테스트다. (고전파 vs 런던파 언급)

## 2. 1. 1 격리 문제에 대한 런던파의 접근
---
런던파는 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 한다. 이런 방식으로 동작을 외부 영향과 분리하여 테스트 대상 클래스에만 집중할 수 있다.

이 접근 방식은 아래와 같은 장점이 있다.
1. 테스트 실패 시 어느 부분이 고장났는지 확실히 알 수 있다.
	1. 외부 시스템을 테스트 대역으로 대체했기 때문에 테스트 대상에 어느 부분이 에러가 났는지 쉽게 알 수 있다.
2. 객체 그래프를 분할할 수 있다.
	1. 객체 그래프를 테스트 대역으로 대체하여 테스트 대상에 집중할 수 있도록 하기 때문이다.
	2. 또한 테스트를 위한 준비 과정을 크게 줄일 수 있다.
3. 부가적인 장점으로 하나의 클래스에 해당하는 하나의 테스트 클래스를 생성한다.

## 2. 1. 2 격리 문제에 대한 고전파의 접근
---
> 공유 의존성, 비공개 의존성, 프로세스 외부 의존성
> 
> 공유 의존성이란 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성. 대표적으로 정적 가변 필드(static mutable field)가 있다.
> 
> 비공개 의존성이란 공유하지 않는 의존성이다.
> 
> 프로세스 외부 의존성이란 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이다. 예를 들어 데이터베이스는 공유 의존성이면서 프로세스 외부 의존성이지만, 테스트 실행 전 도커 컨테이너로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 공유하지 않는 의존성이 된다. 즉, 운영 DB가 아닌 별도의 DB 인스턴스를 의미하며 결과에 서로 영향을 미치지 않는다.

고전파는 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니지만, 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 서로의 결과에 영향을 미치지 않는다.

즉, 여러 클래스를 한 번에 테스트해도 괜찮다는 접근 방식이며 이를 통해 실행 컨텍스트에 영향을 줄 수 있다. 대표적으로 데이터베이스, 파일 시스템과 같은 외부 의존성이다.

공유 의존성은 테스트 대상 클래스 간이 아닌, 단위 테스트 간 공유한다. 싱글톤 의존성은 각 테스트에서 새 인스턴스를 만들 수 있기만 하면 공유되지 않는다.

생성자 등을 통해 다른 모든 의존성이 SUT에 주입되면 각 테스트에서 새 인스턴스를 만들 수 있다. 테스트 스위트 전체에서 단일 인스턴스를 유지할 필요는 없다.

# 2. 2 단위 테스트의 런던파와 고전파
---
런던파와 고전파로 나눠진 원인은 **격리 특성**에 있다. 테스트 대상 시스템에서 런던파는 협력자를, 고전파는  단위 테스트 끼리 격리하는 것으로 본다.

두 개의 분파에 의견 차이가 있는 주제는 아래 3가지와 같다.
- 격리 요구 사항
- 테스트 대상 코드 조각의 구성 요소
- 의존성 처리

![image](https://user-images.githubusercontent.com/37062337/222944033-3be8f6a3-c7e1-4442-8bad-e4439195a585.png)

> 협력자 대 의존성
> 
> 협력자는 공유하거나 변경 가능한 의존성을 의미한다. 예를 들어, 데이터베이스는 공유 의존성이므로 데이터베이스 접근 권한을 제공하는 클래스는 협력자다.
> 
> 일반적인 클래스는 협력자, 값 두 가지 의존성으로 동작한다.
> `customer.Purchase(store, Product.Shampoo, 5)` 에서 store는 협력자로 분류되고, shampoo, 5는 값으로 분류된다.

# 2. 3 고전파와 런던파의 비교
---
고전파와 런던파의 주요 차이는 **단위 테스트의 정의에서 격리 문제를 어떻게 다루는지**에 있는데, 이는 곧 테스트해야 할 단위의 처리와 의존성 취급에 대한 방법으로 넘어간다.

런던파의 접근 방식은 아래와 같은 이점을 제공한다.
- 테스트가 세밀하여 한 번에 한 클래스만 확인한다.
- 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 테스트 대역으로 대체되기 때문이다.
- 테스트 실패 시 어떤 기능이 실패했는지 명확하게 확인 가능하다.

## 2. 3. 1 한 번에 한 클래스만 테스트하기
---
런던파는 클래스를 단위로 간주하는데, OOP에서는 클래스를 모든 코드베이스의 기초에 위치한 원자 빌딩 블록으로 간주한다. 이로 인해 자연스럽게 클래스를 테스트에서 검증할 원자 단위로도 취급하게 된다.

> 테스트는 코드의 단위를 검증하면 안된다. 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야한다. 
> 
> 단위는 여러 클래스에 걸쳐 있을 수도, 한 클래스에서만 있을 수도, 아주 작은 메서드가 될 수도 있다.

## 2. 3. 2 상호 연결된 클래스의 큰 그래프를 단위 테스트 하기
---
실제 협력자를 대신해 mock을 사용하면 클래스를 쉽게 테스트할 수 있다. 테스트 대역을 통해 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다.

상호 연결된 클래스의 크고 복잡한 그래프를 테스트 할 방법을 찾는 대신, 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과이다.

즉, mock을 사용하는 것은 위 클래스 그래프가 커지는 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.

## 2. 3. 3 버그 위치 정확히 찾아내기
---
런던 스타일은 SUT에 버그가 포함된 테스트만 실패하지만, 고전적인 스타일의 경우 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다. 즉, 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급효과를 초래하고, 디버깅과 테스트를 하는데 시간이 더 걸릴 수 있다.

우려할 만한 문제이지만, 큰 문제는 아니며 테스트를 정기적으로 실행하면 원인을 알아낼 수 있다. 또한 실패한 테스트 중 하나를 고치면 다른 테스트도 자동으로 고쳐질 수 있다.

게다가 테스트 스위트 전체에 계단식으로 실패하는 것이 가치가 있는게, 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여주기 때문이다.

## 2. 3. 4 고전파와 런던파 사이의 다른 차이점
---
고전파와 런던파 사이 남아있는 두 가지 차이점은 아래와 같다.
- TDD를 통한 시스템 설계 방식
- 과도한 명세 문제

런던파의 단위 테스트는 하향식 TDD로 이어지며 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트 부터 시작한다. mock을 이용해 협력자를 지정하기 때문이다. 그 다음 모든 클래스를 구현할 때 까지 클래스 그래프를 다져나간다.

고전파는 테스트에서 실제 객체를 다루기 때문에 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때 까지 상향식으로 테스트를 진행한다.

이 둘 간의 가장 중요한 차이점은 테스트가 SUT의 구현 세부 사항에 결합되는 것이다. 런던파는 고전파보다 테스트가 구현에 더 자주 결합되는 편이다. 이로 인해 런던 스타일과 mock을 전반적으로 아무 데나 쓰는 것에 대해 이의가 제기된다.

# 2. 4 두 분파의 통합 테스트
---
고전파의 관점에서 단위 테스트는
- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리한다.

통합 테스트는 이러한 기준을 충족하지 않는 테스트다.

- **단일 동작 단위를 검증하고**
	- 통합 테스트에서 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다.
	- 이런 간섭을 피하려면 추가적인 조치를 취해야 한다.
- **빠르게 수행하고**
	- 프로세스 외부 의존성에 접근하면 테스트가 느려진다.
- **다른 테스트와 별도로 처리한다.**
	- 통합 테스트의 테스트 스위트 실행 속도를 빠르게 하기 위해 둘 이상의 동작 단위를 하나의 테스트로 동작시킬 수 있다.

## 2. 4. 1 통합 테스트의 일부인 엔드 투 엔드 테스트
---
통합 테스트는 공유 의존성, 프로세스 외부 의존성 뿐 아니라 조직 내 다른 팀이 개발한 코드와 통합해 작동하는지도 검증하는 테스트다.

엔드 투 엔드 테스트는 통합 테스트의 일부이며, 통합 테스트와의 차이점은 엔드 투 엔드 테스트가 일반적으로 의존성을 더 많이 포함한다는 것이다.

일반적으로 통합 테스트는 외부 의존성을 한 두개만 가지고 동작한다. 반면 엔드 투 엔드 테스트는 프로세스 외부 의존성을 전부 또는 대다수를 갖고 작동한다.

애플리케이션이 DB, 파일 시스템, 결제 게이트웨이라는 세 가지 프로세스 외부 의존성으로 작동한다고 가정했을 때, 일반적인 통합 테스트는 DB와 파일 시스템만 포함하고, 결제 게이트웨이는 테스트 대역으로 대체한다.

DB, 파일 시스템은 완전히 제어할 수 있기 때문에 필요한 상태로 쉽게 가져올 수 있지만, 결제 시스템은 그렇지 못하기 때문이다.

엔드 투 엔드 테스트는 유지보수 측면에서 가장 비용이 많이 든다. 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다.

엔드 투 엔드 테스트를 진행하더라도 모든 프로세스 외부 의존성을 처리하지 못할 수 있다. 일부 의존성의 테스트 버전이 없거나 해당 의존성을 필요한 상태로 자동으로 가져오는 것이 불가능할 수 있기에 테스트 대역을 여전히 사용할 필요가 있다.
