```toc
```
# 서론

지금까지 바운디드 컨텍스트, 서브도메인, 컨텍스트 맵을 통해 전략적 설계에 대해 알아봤다. 

![[KakaoTalk_Photo_2023-01-01-17-15-41.jpeg]]

위 두개의 바운디드 컨텍스트에서는 **애자일 프로젝트 관리 컨텍스트**라는 이름의 핵심 도메인이 있고, 컨텍스트 매핑 통합 기반의 협업 도구를 제공하는 **지원 서브도메인**이 있다.

# 애그리게잇이란?

![[Pasted image 20230101172012.png]]

위사진에서 Product, BacklogItem...과 같이 동그라미 표시된 개념들은 모델 안에 존재하는 **애그리게잇**이다. 동그라미를 치지 않은 Discussion은 값 객체(Value Object)로 모델링한 것이다. 이번 장에서는 애그리게잇에 초점을 맞출 것이기에 Product, BacklogItem, Release, Sprint 를 모델링하는 방법에 대해 자세히 이야기 해본다.

> 엔티티(Entity)란?
> 
> 엔티티는 독립적인 것이다. 각 엔티티는 같은 형태를 띠거나 다른 형태의 엔티티들과의 특성을 구별할 수 있는 고유한 식별성을 갖는다.
> 
> 엔티티의 상태는 계속해서 변할 수 있고, 다른 모델링 수단과 엔티티를 구분해주는 주 요인은 유일성, 즉 그것의 독립성에 있다.

![[Pasted image 20230101172607.png]]

그렇다면 애그리게잇은 무엇일까? 위 그림에서 각 애그리게잇은 1개 이상의 엔티티로 구성되고, 그 중 한 엔티티는 애그리게잇 루트라고 부른다. 애그리게잇은 그 구성에 값 객체를 포함할 수 있다. 여기서는 두 애그리게잇 모두 값 객체를 포함하고 있다.

> VO(Value Object)란?
> 
> 값은 불변의 개념적 완전성을 모델링한다. 엔티티와 달리 고유한 식별성이 없으며 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.
> 
> 뿐만 아니라 값 객체가 어떤 것을 나타내기 보다는 엔티티 자체를 서술하고, 수량화하거나 측정하는데 사용된다.

![[Pasted image 20230101173033.png]]

각 애그리게잇의 루트 엔티티는 애그리게잇 안의 다른 모든 요소들을 소유한다. **루트 엔티티의 명칭은 애그리게잇의 개념적 명칭이다.** 애그리게잇이 모델링하는 개념적 완전성을 적절하게 표현할 수 있는 명칭으로 루트 엔티티 명칭을 정의해야한다.

![[Pasted image 20230101173222.png]]

각 애그리게잇은 일관성 있는 트랜잭션 경계를 형성한다. 이것은 **트랜잭션 제어가 데이터베이스에 커밋될 때, 한 애그리게잇 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서 일관성 있게 처리된다는 것을 의미한다.**

다만, 애그리게잇 내에 트랜잭션 이후 일관성이 지켜질 필요가 없는 다른 요소를 포함해서는 안된다는 것은 아니다. **애그리게잇은 개념적으로 완전하게 모델링해야 하기 때문이다.**

트랜잭션의 일관성에 신경써야하는 것은 분명하며, 위 그림에서 그려진 빨간 동그라미(외부 경계)는 그 애그리게잇에 대한 데이터 처리 원칙을 유지하고 제어하는 **트랜잭션으로 분리**되어있음을 의미한다.

> 넓은 의미의 트랜잭션
> 
> 애플리케이션에 대한 트랜잭션 사용은 어느 정도 구현에 관한 세부사항이다.
> 
> 예를 들어, 도메인 모델에 일관성 있는 데이터베이스 트랜잭션을 제어하는 애플리케이션 서비스는 비교적 일반적이다. 하지만 Reactive와 같은 다른 아키텍처 활용 사례에서는 각 애그리게잇을 액터로 구현하고, 트랜잭션은 데이터베이스에 대한 원자적 트랜잭션을 지원하지 않는 이벤트 소싱을 사용한다.
> 
> 어느 쪽이든, 트랜잭션이란 애그리게잇에 대한 변경을 독립시키고, 소프트웨어가 언제나 충실히 준수해야하는 비즈니스 규칙의 불변성을 일관성있게 보장하는 방법이다.

트랜잭션의 경계를 두는 이유는 애그리게잇이 유효한 상태인지, 아닌지를 결정하는 비즈니스와 관련돼 있는 일이기 때문이다. 다시 말해, 애그리게잇이 완전하고 유효한 상태로 저장되지 않는다면, **수행된 비즈니스 오퍼레이션은 비즈니스 규칙에 어긋난 것으로 간주**해야할 것이다.

![[Pasted image 20230101174450.png]]

위 사진에서 2개의 애그리게잇이 정의되어 있는데, 둘 중 하나만 단일 트랜잭션으로 커밋되어야 한다면.. 즉, 하나의 트랜잭션에는 오직 1개의 애그리게잇만을 수정하고 커밋한다는 것이 애그리게잇 설계 규칙이라고 가정해보자. 하나의 트랜잭션에 "애그리게잇 형태 1" 만 존재하는 이유이다.

![[Pasted image 20230101174830.png]]

또 다른 애그리게잇은 별도 분리된 트랜잭션으로 수정, 커밋된다. 이런 이유로 **애그리게잇을 트랜잭션의 일관성을 만드는 경계**라고 불리며, 트랜잭션의 일관성과 성공을 보장하도록 애그리게잇 구성 요소들을 설계해야한다. 따라서 위 예제의 "애그리게잇 형태 2"는 "애그리게잇 형태 1"로부터 분리된 트랜잭션으로 제어되어야 한다.

![[Pasted image 20230101175059.png]]

이 두 애그리게잇의 인스턴스는 분리된 트랜잭션으로 설계된다. 그렇다면 "애그리게잇 형태 1" 인스턴스의 변경이 반드시 이뤄진 후 이를 기반으로 "애그리게잇 형태 2" 인스턴스를 변경하도록 할 수 있을까? 이는 잠시 뒤에서 언급한다.

정리하자면, 비즈니스 규칙은 단일 트랜잭션을 마쳤을 때, 어떤 것이 전체적으로 완전하게 그리고 일관성있게 처리돼야 하는지를 결정하는 근거라는 점이다.

# 애그리게잇 경험 법칙

아래 애그리게잇 설계의 네 가지 기본 규칙이 있다.
1. 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라
2. 작은 애그리게잇을 설계하라
3. 오직 ID를 통해 다른 애그리게잇을 참조하라
4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라

위 규칙은 강요는 아니지만 DDD를 신중하게 생각할 때, 효과적으로 동작하는 애그리게잇을 설계할 수 있도록 도움을 주는 가이드로 받아들이는 것이 좋다. 이 규칙을 적용하고자 할 때, 각 규칙들이 어떻게 적용돼야 하는지 좀 더 알아보자.

![[Pasted image 20230101175710.png]]

## 규칙 1. 애그리게잇 경계 내의 비즈니스 불변사항을 보호하라

결과적으로 규칙 1은 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반하여 애그리게잇 구성 요소를 결정해야 한다는 의미이다. 위에서 Product는 트랜잭션의 끝에 ProductBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Product의 루트와 일관되게 처리하도록 설계한다.

![[Pasted image 20230102043825.png]]

위 BacklogItem 애그리게잇에서 "모든 Task 인스턴스의 `hoursRemaining`이 0일 때, BacklogItem의 status는  반드시 Done으로 설정해야한다." 라는 비즈니스 규칙이 있다. 이는 트랜잭션 후 반드시 부합돼야 하는 매우 명확한 비즈니스 불변사항이며 비즈니스 요청사항이다.

## 규칙 2. 작은 애그리게잇을 설계하라

![[Pasted image 20230102044110.png]]

이 규칙은 각 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야함을 강조한다. 위 애그리게잇은 규모가 작지 않다. 여기서 Product는 BacklogItem, Release, Sprint의 가능한 가장 큰 모음을 담고 있다. 시간이 지나면서 BacklogItem, Release, Sprint 인스턴스들은 숫자가 늘어날 수 밖에 없는데, 일반적으로 이런 설계 방식은 좋지 않다.

![[Pasted image 20230102044412.png]]

하지만 Product 애그리게잇을 위처럼 4개의 애그리게잇으로 분해하면 작은 Product, BacklogItem, Release, Sprint 애그리게잇을 얻을 수 있다. 이들은 빠르게 로드되고, 더 작은 메모리를 차지하며, 가비지 컬렉션도 더 빠르다. 하지만 가장 중요한 것은 **이 애그리게잇들은 이전의 큰 클러스터의 Product 애그리게잇보다 훨씬 더 자주, 성공적인 트랜잭션을 수행할 것이라는 점이다.**

이 규칙을 따른다면, 연관된 각 작업이 한 명의 개발자가 관리할 수 있을 만큼 작기에 애그리게잇이 좀 더 쉬워지는 부가적인 이득을 얻을 수 있으며, 테스트 또한 보다 더 쉬워질 것이다.

애그리게잇을 설계할 때, 깊이 새겨둬야 할 사항은 SRP라는 **단일 책임의 원칙이다.** 만일 애그리게잇이 너무 많은 일을 한다면 SRP를 따르지 않는 것이고, 이후 애그리게잇의 크기의 관해 재논의할 가능성이 크다.

```
- Product가 스크럼 제품에 주안점을 두고 있는지?
- 아니면 다른 것도 함께 추구하는 것인지?
- Product를 변경하는 이유가 더 나은 스크럼 제품을 만들기 위해서일까?
- 아니면 BacklogItem, Release, Sprint를 관리하기 위해서일까?
```

## 규칙 3. 오직 식별자로만 다른 애그리게잇을 참고하라

![[Pasted image 20230102045024.png]]

앞에서 큰 Product 애그리게잇을 4개의 작은 애그리게잇으로 분리했다. 이제 각각의 애그리게잇들은 필요한 다른 애그리게잇들을 어떻게 참고해야할까? 여기서 규칙 3인 **식별자로만 다른 애그리게잇을 참고하라**를 따른다.

위 그림에서 BacklogItem, Release, Sprint 모두가 ProductID를 가지고 있음으로써 Product를 참고하는 것을 확인할 수 있다. 이것은 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에서 여러 애그리게잇을 수정하려는 접근을 방지한다. 이유는 식별자 외에는 다른 애그리게잇에 접근할 수 없기 때문이다.

또한, 더 적은 메모리 요구와 리파지토리로부터의 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다.

또 다른 이점으로는 애그리게잇을 `관계형 데이터베이스`, `문서 데이터베이스`, `Key - Value 리파지토리`, `데이터 그리드/패브릭`과 같은 다른 형태의 저장 메커니즘으로도 쉽게 저장할 수 있다는 것이다. 즉, 리파지토리의 사용을 선택적으로 결정할 수 있다는 것을 의미한다.

## 규칙 4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라

![[Pasted image 20230102045831.png]]

여기서 BacklogItem과 Sprint는 연계 수행된다. 먼저, BacklogItem은 연관된 Sprint를 알아야한다. 이는 BacklogItem의 상태가 해당 Sprint의 SprintID를 갖도록 정의하며 하나의 트랜잭션 안에서 관리된다. 그럼 Sprint 관점에서 새롭게 할당된 BacklogItem의 BacklogItemID로 관계를 맺어 제대로 실행되었는지 어떻게 확신할 수 있을까?

![[Pasted image 20230102050213.png]]

BacklogItem 애그리게잇의 트랜잭션의 일부로, `BacklogItemCommitted`라는 도메인 이벤트를 발행시킨다. BacklogItem 트랜잭션을 완료한 후의 상태는 BacklogItemCommitted 도메인 이벤트를 통해 유지된다. BacklogItemCommitted 이벤트가 구독자에게 전달되면, 트랜잭션이 시작되고 Sprint의 상태는 할당된 BacklogItem의 BacklogItemID를 보유하도록 수정된다. 이제 Sprint는 새로운 CommittedBacklogItem 엔티티 안에 BacklogItemID를 보유한다.

![[Pasted image 20230102050535.png]]

도메인 이벤트는 애그리게잇에 의해 발행되고, 이에 관심있는 바운디드 컨텍스트는 이를 전달받는다. 이처럼 메시징 메커니즘은 구독을 통해 관심있는 파티들에게 도메인 이벤트를 전달한다. 관심있는 바운디드 컨텍스트는 도메인 이벤트를 발행한 컨텍스트일 수 있고, 다른 바운디드 컨텍스트일 수 있다.

![[Pasted image 20230102050722.png]]

BacklogItem 애그리게잇과 Sprint 애그리게잇의 경우, 발행자와 구독자가 같은 바운디드 컨텍스트에 있다. 굳이 이런 상황을 위해 메시징 미들웨어를 사용할 이유는 없지만 다른 바운디드 컨텍스트에 이벤트를 발행시키기 위한 용도로 메시징 제품을 사용하고 있다면, 이 경우에도 메시징 미들웨어 제품을 활용해보자.

> 결과적 일관성이 두렵게 느껴진다면?
> 
> 이를 실제로 경험해보기 전 까지는 결과적 일관성 사용에 대한 걱정이 있을 수 있다. 그렇다고 해도 비즈니스에 의해 정의된 트랜잭션 경계에 따라 모델을 애그리게잇으로 분리시켜야 한다.
> 
> 예전처럼 2개 이상의 애그리게잇을 단일한 데이터베이스 트랜잭션으로 묶어 처리하고 싶을 수도 있지만 다른 모두를 위해 일관성있게 사용할 필요가 있다. 이는 초기 단계부터 너무 거대한 처리를 만들지 않도록 해주는 기법이다.

# 애그리게잇 모델링

