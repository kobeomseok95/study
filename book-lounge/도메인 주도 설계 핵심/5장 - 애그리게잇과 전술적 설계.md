```toc
```
# 서론

지금까지 바운디드 컨텍스트, 서브도메인, 컨텍스트 맵을 통해 전략적 설계에 대해 알아봤다. 

![image](https://user-images.githubusercontent.com/37062337/210369202-e053363c-b2a1-458a-b28a-2d89b39600a6.png)

위 두개의 바운디드 컨텍스트에서는 **애자일 프로젝트 관리 컨텍스트**라는 이름의 핵심 도메인이 있고, 컨텍스트 매핑 통합 기반의 협업 도구를 제공하는 **지원 서브도메인**이 있다.

# 애그리게잇이란?

![image](https://user-images.githubusercontent.com/37062337/210369236-14b1dfbf-2454-415c-9cd3-7290e96a1bf0.png)

위사진에서 Product, BacklogItem...과 같이 동그라미 표시된 개념들은 모델 안에 존재하는 **애그리게잇**이다. 동그라미를 치지 않은 Discussion은 값 객체(Value Object)로 모델링한 것이다. 이번 장에서는 애그리게잇에 초점을 맞출 것이기에 Product, BacklogItem, Release, Sprint 를 모델링하는 방법에 대해 자세히 이야기 해본다.

> 엔티티(Entity)란?
> 
> 엔티티는 독립적인 것이다. 각 엔티티는 같은 형태를 띠거나 다른 형태의 엔티티들과의 특성을 구별할 수 있는 고유한 식별성을 갖는다.
> 
> 엔티티의 상태는 계속해서 변할 수 있고, 다른 모델링 수단과 엔티티를 구분해주는 주 요인은 유일성, 즉 그것의 독립성에 있다.

![image](https://user-images.githubusercontent.com/37062337/210369319-16f3dcb5-1673-44f3-affc-f2cc68735118.png)

그렇다면 애그리게잇은 무엇일까? 위 그림에서 각 애그리게잇은 1개 이상의 엔티티로 구성되고, 그 중 한 엔티티는 애그리게잇 루트라고 부른다. 애그리게잇은 그 구성에 값 객체를 포함할 수 있다. 여기서는 두 애그리게잇 모두 값 객체를 포함하고 있다.

> VO(Value Object)란?
> 
> 값은 불변의 개념적 완전성을 모델링한다. 엔티티와 달리 고유한 식별성이 없으며 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.
> 
> 뿐만 아니라 값 객체가 어떤 것을 나타내기 보다는 엔티티 자체를 서술하고, 수량화하거나 측정하는데 사용된다.

![image](https://user-images.githubusercontent.com/37062337/210369395-f1b38e2e-851c-4bc6-86b7-1379e4d9b8e9.png)

각 애그리게잇의 루트 엔티티는 애그리게잇 안의 다른 모든 요소들을 소유한다. **루트 엔티티의 명칭은 애그리게잇의 개념적 명칭이다.** 애그리게잇이 모델링하는 개념적 완전성을 적절하게 표현할 수 있는 명칭으로 루트 엔티티 명칭을 정의해야한다.

![image](https://user-images.githubusercontent.com/37062337/210369457-1dc39057-c6be-465b-8bb1-76a950f4b143.png)

각 애그리게잇은 일관성 있는 트랜잭션 경계를 형성한다. 이것은 **트랜잭션 제어가 데이터베이스에 커밋될 때, 한 애그리게잇 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서 일관성 있게 처리된다는 것을 의미한다.**

다만, 애그리게잇 내에 트랜잭션 이후 일관성이 지켜질 필요가 없는 다른 요소를 포함해서는 안된다는 것은 아니다. **애그리게잇은 개념적으로 완전하게 모델링해야 하기 때문이다.**

트랜잭션의 일관성에 신경써야하는 것은 분명하며, 위 그림에서 그려진 빨간 동그라미(외부 경계)는 그 애그리게잇에 대한 데이터 처리 원칙을 유지하고 제어하는 **트랜잭션으로 분리**되어있음을 의미한다.

> 넓은 의미의 트랜잭션
> 
> 애플리케이션에 대한 트랜잭션 사용은 어느 정도 구현에 관한 세부사항이다.
> 
> 예를 들어, 도메인 모델에 일관성 있는 데이터베이스 트랜잭션을 제어하는 애플리케이션 서비스는 비교적 일반적이다. 하지만 Reactive와 같은 다른 아키텍처 활용 사례에서는 각 애그리게잇을 액터로 구현하고, 트랜잭션은 데이터베이스에 대한 원자적 트랜잭션을 지원하지 않는 이벤트 소싱을 사용한다.
> 
> 어느 쪽이든, 트랜잭션이란 애그리게잇에 대한 변경을 독립시키고, 소프트웨어가 언제나 충실히 준수해야하는 비즈니스 규칙의 불변성을 일관성있게 보장하는 방법이다.

트랜잭션의 경계를 두는 이유는 애그리게잇이 유효한 상태인지, 아닌지를 결정하는 비즈니스와 관련돼 있는 일이기 때문이다. 다시 말해, 애그리게잇이 완전하고 유효한 상태로 저장되지 않는다면, **수행된 비즈니스 오퍼레이션은 비즈니스 규칙에 어긋난 것으로 간주**해야할 것이다.

![image](https://user-images.githubusercontent.com/37062337/210369513-4504d2bf-d3c1-4e3b-acc1-94c51a920fd5.png)

위 사진에서 2개의 애그리게잇이 정의되어 있는데, 둘 중 하나만 단일 트랜잭션으로 커밋되어야 한다면.. 즉, 하나의 트랜잭션에는 오직 1개의 애그리게잇만을 수정하고 커밋한다는 것이 애그리게잇 설계 규칙이라고 가정해보자. 하나의 트랜잭션에 "애그리게잇 형태 1" 만 존재하는 이유이다.

![image](https://user-images.githubusercontent.com/37062337/210369566-f7095cb7-fe93-4a0c-b75f-7a7d88555996.png)

또 다른 애그리게잇은 별도 분리된 트랜잭션으로 수정, 커밋된다. 이런 이유로 **애그리게잇을 트랜잭션의 일관성을 만드는 경계**라고 불리며, 트랜잭션의 일관성과 성공을 보장하도록 애그리게잇 구성 요소들을 설계해야한다. 따라서 위 예제의 "애그리게잇 형태 2"는 "애그리게잇 형태 1"로부터 분리된 트랜잭션으로 제어되어야 한다.

![image](https://user-images.githubusercontent.com/37062337/210369631-2cb4f7ad-14dc-4cf8-b00c-530ff4ca553e.png)

이 두 애그리게잇의 인스턴스는 분리된 트랜잭션으로 설계된다. 그렇다면 "애그리게잇 형태 1" 인스턴스의 변경이 반드시 이뤄진 후 이를 기반으로 "애그리게잇 형태 2" 인스턴스를 변경하도록 할 수 있을까? 이는 잠시 뒤에서 언급한다.

정리하자면, 비즈니스 규칙은 단일 트랜잭션을 마쳤을 때, 어떤 것이 전체적으로 완전하게 그리고 일관성있게 처리돼야 하는지를 결정하는 근거라는 점이다.

# 애그리게잇 경험 법칙

아래 애그리게잇 설계의 네 가지 기본 규칙이 있다.
1. 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라
2. 작은 애그리게잇을 설계하라
3. 오직 ID를 통해 다른 애그리게잇을 참조하라
4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라

위 규칙은 강요는 아니지만 DDD를 신중하게 생각할 때, 효과적으로 동작하는 애그리게잇을 설계할 수 있도록 도움을 주는 가이드로 받아들이는 것이 좋다. 이 규칙을 적용하고자 할 때, 각 규칙들이 어떻게 적용돼야 하는지 좀 더 알아보자.

![image](https://user-images.githubusercontent.com/37062337/210369682-7912e3c3-399f-4c43-b822-a76228816e5f.png)

## 규칙 1. 애그리게잇 경계 내의 비즈니스 불변사항을 보호하라

결과적으로 규칙 1은 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반하여 애그리게잇 구성 요소를 결정해야 한다는 의미이다. 위에서 Product는 트랜잭션의 끝에 ProductBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Product의 루트와 일관되게 처리하도록 설계한다.

![image](https://user-images.githubusercontent.com/37062337/210369782-fa89680c-8830-44ed-88bd-0576163a3a84.png)

위 BacklogItem 애그리게잇에서 "모든 Task 인스턴스의 `hoursRemaining`이 0일 때, BacklogItem의 status는  반드시 Done으로 설정해야한다." 라는 비즈니스 규칙이 있다. 이는 트랜잭션 후 반드시 부합돼야 하는 매우 명확한 비즈니스 불변사항이며 비즈니스 요청사항이다.

## 규칙 2. 작은 애그리게잇을 설계하라

![image](https://user-images.githubusercontent.com/37062337/210369862-e1c6b5a1-5903-42f1-b7b1-e4796cbe3e22.png)

이 규칙은 각 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야함을 강조한다. 위 애그리게잇은 규모가 작지 않다. 여기서 Product는 BacklogItem, Release, Sprint의 가능한 가장 큰 모음을 담고 있다. 시간이 지나면서 BacklogItem, Release, Sprint 인스턴스들은 숫자가 늘어날 수 밖에 없는데, 일반적으로 이런 설계 방식은 좋지 않다.

![image](https://user-images.githubusercontent.com/37062337/210369912-f3a263de-73fb-4975-a7e3-328147050f29.png)

하지만 Product 애그리게잇을 위처럼 4개의 애그리게잇으로 분해하면 작은 Product, BacklogItem, Release, Sprint 애그리게잇을 얻을 수 있다. 이들은 빠르게 로드되고, 더 작은 메모리를 차지하며, 가비지 컬렉션도 더 빠르다. 하지만 가장 중요한 것은 **이 애그리게잇들은 이전의 큰 클러스터의 Product 애그리게잇보다 훨씬 더 자주, 성공적인 트랜잭션을 수행할 것이라는 점이다.**

이 규칙을 따른다면, 연관된 각 작업이 한 명의 개발자가 관리할 수 있을 만큼 작기에 애그리게잇이 좀 더 쉬워지는 부가적인 이득을 얻을 수 있으며, 테스트 또한 보다 더 쉬워질 것이다.

애그리게잇을 설계할 때, 깊이 새겨둬야 할 사항은 SRP라는 **단일 책임의 원칙이다.** 만일 애그리게잇이 너무 많은 일을 한다면 SRP를 따르지 않는 것이고, 이후 애그리게잇의 크기의 관해 재논의할 가능성이 크다.

```
- Product가 스크럼 제품에 주안점을 두고 있는지?
- 아니면 다른 것도 함께 추구하는 것인지?
- Product를 변경하는 이유가 더 나은 스크럼 제품을 만들기 위해서일까?
- 아니면 BacklogItem, Release, Sprint를 관리하기 위해서일까?
```

## 규칙 3. 오직 식별자로만 다른 애그리게잇을 참고하라

![image](https://user-images.githubusercontent.com/37062337/210369965-3ce769a2-a0f3-4701-9f3f-e5407bcb906d.png)

앞에서 큰 Product 애그리게잇을 4개의 작은 애그리게잇으로 분리했다. 이제 각각의 애그리게잇들은 필요한 다른 애그리게잇들을 어떻게 참고해야할까? 여기서 규칙 3인 **식별자로만 다른 애그리게잇을 참고하라**를 따른다.

위 그림에서 BacklogItem, Release, Sprint 모두가 ProductID를 가지고 있음으로써 Product를 참고하는 것을 확인할 수 있다. 이것은 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에서 여러 애그리게잇을 수정하려는 접근을 방지한다. 이유는 식별자 외에는 다른 애그리게잇에 접근할 수 없기 때문이다.

또한, 더 적은 메모리 요구와 리파지토리로부터의 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다.

또 다른 이점으로는 애그리게잇을 `관계형 데이터베이스`, `문서 데이터베이스`, `Key - Value 리파지토리`, `데이터 그리드/패브릭`과 같은 다른 형태의 저장 메커니즘으로도 쉽게 저장할 수 있다는 것이다. 즉, 리파지토리의 사용을 선택적으로 결정할 수 있다는 것을 의미한다.

## 규칙 4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라

![image](https://user-images.githubusercontent.com/37062337/210370024-1f720e18-4034-47c4-bee1-e99722b919e1.png)

여기서 BacklogItem과 Sprint는 연계 수행된다. 먼저, BacklogItem은 연관된 Sprint를 알아야한다. 이는 BacklogItem의 상태가 해당 Sprint의 SprintID를 갖도록 정의하며 하나의 트랜잭션 안에서 관리된다. 그럼 Sprint 관점에서 새롭게 할당된 BacklogItem의 BacklogItemID로 관계를 맺어 제대로 실행되었는지 어떻게 확신할 수 있을까?

![image](https://user-images.githubusercontent.com/37062337/210370092-8af2d49b-59c4-47d7-a4ec-0e81c22c5be7.png)

BacklogItem 애그리게잇의 트랜잭션의 일부로, `BacklogItemCommitted`라는 도메인 이벤트를 발행시킨다. BacklogItem 트랜잭션을 완료한 후의 상태는 BacklogItemCommitted 도메인 이벤트를 통해 유지된다. BacklogItemCommitted 이벤트가 구독자에게 전달되면, 트랜잭션이 시작되고 Sprint의 상태는 할당된 BacklogItem의 BacklogItemID를 보유하도록 수정된다. 이제 Sprint는 새로운 CommittedBacklogItem 엔티티 안에 BacklogItemID를 보유한다.

![image](https://user-images.githubusercontent.com/37062337/210370138-df31786f-031c-4fde-afb4-c294358ebaf1.png)

도메인 이벤트는 애그리게잇에 의해 발행되고, 이에 관심있는 바운디드 컨텍스트는 이를 전달받는다. 이처럼 메시징 메커니즘은 구독을 통해 관심있는 파티들에게 도메인 이벤트를 전달한다. 관심있는 바운디드 컨텍스트는 도메인 이벤트를 발행한 컨텍스트일 수 있고, 다른 바운디드 컨텍스트일 수 있다.

![image](https://user-images.githubusercontent.com/37062337/210370198-2609ea34-9717-4d79-b115-eb4a694482cc.png)

BacklogItem 애그리게잇과 Sprint 애그리게잇의 경우, 발행자와 구독자가 같은 바운디드 컨텍스트에 있다. 굳이 이런 상황을 위해 메시징 미들웨어를 사용할 이유는 없지만 다른 바운디드 컨텍스트에 이벤트를 발행시키기 위한 용도로 메시징 제품을 사용하고 있다면, 이 경우에도 메시징 미들웨어 제품을 활용해보자.

> 결과적 일관성이 두렵게 느껴진다면?
> 
> 이를 실제로 경험해보기 전 까지는 결과적 일관성 사용에 대한 걱정이 있을 수 있다. 그렇다고 해도 비즈니스에 의해 정의된 트랜잭션 경계에 따라 모델을 애그리게잇으로 분리시켜야 한다.
> 
> 예전처럼 2개 이상의 애그리게잇을 단일한 데이터베이스 트랜잭션으로 묶어 처리하고 싶을 수도 있지만 다른 모두를 위해 일관성있게 사용할 필요가 있다. 이는 초기 단계부터 너무 거대한 처리를 만들지 않도록 해주는 기법이다.

# 애그리게잇 모델링

도메인 모델 관련, 애그리게잇 구현에 대한 작업 시 실수하는 것 중 하나는 **객체지향 도메인 모델을 사용하면서 모든 애그리게잇이 비즈니스 행위가 아닌 읽고 쓰는 공개 접근자만을 갖는 것이다.** 이는 기술적인 부분에 초점을 맞췄을 때 발생하는 경향이 있다. 이렇게 **빈약한 도메인 모델을 설계하는 것은 도메인 모델이 주는 혜택을 받지 못하고, 모든 오버헤드를 떠안아버리는 상황을 만든다.**

또한 비즈니스 로직이 도메인 모델을 넘어 애플리케이션 서비스까지 새어 나가지 않도록 주의해야한다. 이것은 빈약한 도메인 모델처럼 잘 발견되지 않을 수 있다. 

비즈니스 로직을 도우미나 유틸리티 클래스에 위임하는 것은 원하는 대로 동작하지 않는다. 서비스 유틸리티는 항상 정체성에 혼란을 주고, 요구사항을 올바르게 유지시키지도 못한다. **비즈니스 로직을 도메인 모델 안에 정의하지 못한다면, 빈약한 도메인 모델이 만들어낸 버그들 때문에 고생할 수 밖에 없다.**

> 함수형 프로그래밍의 경우는?
> 
> 함수형 프로그래밍에서는 데이터와 행위의 분리를 장려한다. 즉, 불변하는 데이터 구조나 레코드 유형으로 데이터를 설계하고, 이렇게 설계된 데이터를 제어하는 순수한 함수로 행위를 구현하는 방식이다.
> 
> 함수가 인자로 받은 데이터를 수정하는 대신, 함수가 새로운 값을 반환한다. 이 새로운 값은 애그리게잇의 상태 변환을 나타내주는 도메인 이벤트 또는 집합의 새로운 상태가 된다.

![image](https://user-images.githubusercontent.com/37062337/210357143-57615483-1c51-4e10-b20a-3c458b5843d0.png)

이제 기초적인 애그리게잇 설계를 구현해야 할 기술적인 컴포넌트 중 일부를 살펴보자. 

![image](https://user-images.githubusercontent.com/37062337/210357419-abf2df4b-b232-4e07-8246-cd02ec2433de.png)

```kotlin
class Product () { }
```

가장 먼저 할 것은 애그리게잇 루트 엔티티 클래스를 생성하는 것이다. 

![image](https://user-images.githubusercontent.com/37062337/210357601-4c204403-3aaf-4fd2-bcdc-c196e8f27f27.png)

```kotlin
class Product (
	val productId: ProductId,
	val tenantId: TenantId,
)
```

모든 에그리게잇 루트 엔티티는 전체 시스템에서 고유한 식별성을 가져야한다. 실제 애자일 프로젝트 관리 컨텍스트에서 Product는 두 가지 형태의 전역적인 고유 식별성을 갖고 있다. TenantId는 특정한 구독자 조직 내에서 루트 엔티티를 식별한다.(제공되는 서비스를 구독하는 모든 조직은 Tenant로 표현, 이를 위해 고유한 식별성을 갖고 있음)

두 번째 식별성도 전역적인 고유한 ProductId다. 이 식별성은 동일한 Tenant 내의 다른 모든 것들로부터 Product를 구별시켜준다. 여기서 ProductId와 TenantId는 모두 변하지 않는 값 객체로 구현했다.

![image](https://user-images.githubusercontent.com/37062337/210358199-ba0ea914-811e-4710-8d6b-65ae73d7cc55.png)

```kotlin
class Product (
	val productId: ProductId,
	val tenantId: TenantId,
	var description: String,
	var name: String,
)
```

다음은 애그리게잇을 찾는데 필요한 본질적인 속성이나 필드를 찾는다. Product의 경우 description과 name이 존재한다. 사용자들은 각각의 Product를 찾기 위해 이들 중 하나 또는 둘 모두를 검색해볼 수 있다.

![image](https://user-images.githubusercontent.com/37062337/210358590-360e8036-d770-46bd-b91c-a1718cd0c865.png)

```kotlin
class Product (
	val productId: ProductId,
	val tenantId: TenantId,
	description: String,
	name: String,
) {
	var description: String = description
		private set
	var name: String = name
		private set
}
```

만약 속성 쓰기(setter) 메서드를 공개한다면, Product의 값 설정을 위한 로직이 모델 밖에 구현될 것이기 때문에 빈약한 도메인으로 쉽게 빠질 수 있다.

![image](https://user-images.githubusercontent.com/37062337/210359427-073deb8c-3830-4043-8d6b-9cacec297f8e.png)

마지막으로 행위를 추가해보자. 위 그림에서는 PlanBacklogItem(), PlannedProductBacklogItem(), ScheduleRelease(), ScheduleSprint() 라는 4개의 메서드가 있다. 이 메서드를 모두 Product 클래스에 추가해야 한다.

![image](https://user-images.githubusercontent.com/37062337/210360069-b0f819ac-b66c-4036-89b3-669b539f525b.png)

DDD를 사용할 때는 항상 바운디드 컨텍스트 내의 보편언어를 모델링한다는 것을 항상 기억해야한다. 따라서 Product 애그리게잇의 모든 부분은 보편언어에 따라 모델링 해야한다. 단지 생각했던 부분들을 만드는데 급급하면 안되며, 모든 것이 조화를 이룰 수 있도록 도메인 전문가와 개발자들 사이에 긴밀한 협업이 필요하다.

# 추상화를 조심스럽게 선택하라

효과적인 소프트웨어 모델은 항상 일을 하는 비즈니스의 방식을 고려한 일련의 추상화에 기반을 두고 있다. 이 때 모델링하는 각 개념마다 적절한 수준의 추상화를 선택해야 한다.

만일, 보편언어와 관련된 가이드를 따르면 적절한 추상화를 설정할 수 있다. 적어도 모델링 언어의 기반에 지식을 전달해주는 도메인 전문가가 있기 때문에 훨씬 정확하게 추상화를 모델링할 수 있다. 하지만 가끔은 잘못된 문제를 푸는 것에 지나치게 몰두하여 추상화를 적용하기도 한다.

예를 들면, 애자일 프로젝트 관리 컨텍스트에서의 스크럼 관련 사항을 돌이켜보자. Product, BacklogItem, Release, Sprint 개념을 모델링하는 것은 타당하다. 만약 개발자가 보편언어를 모델링하는 것에 그다지 관심을 기울이지 않은 채, 현재와 미래의 모든 스크럼 관련 개념을 모델링하는 것에 더 많은 관심을 갖고 있다면 어떻게 될까?

이런 관점이 계속 된다면, 개발자들은 ScrumElement, ScrumElementContainer와 같은 개념을 생각해낼 것이다. ScrumElement는 Product와 BacklogItem 에 대한 현재 요구사항을 만족시키고 ScrumElementContainer는 Release와 Sprint의 명확한 개념을 분명히 표현해줄 것이기 때문이다.

ScrumElement는 typeName 프로퍼티를 가질 것이고, 아마도 그 값은 상황에 맞게 Product나 BacklogItem으로 설정될 것이다. ScrumElementContainer도 typeName 프로퍼티를 설계하고 Release나 Sprint로 설정할 것이다.

이런 방식에서 나타나는 문제점은 아래와 같다.
- 소프트웨어 모델의 언어가 도메인 전문가의 멘탈 모델과 일치하지 않는다.
- 추상화 수준이 너무 높아 각 개별적인 형태의 세부 사항을 모델링하기 시작하면 어려운 상황에 빠질 것이다.
- 이 방식은 클래스마다 특수한 경우를 정의할 것이고, 명백한 무제들에 대한 일반적인 접근을 통해 복잡한 클래스 계층 구조를 만들 것이다.
- 중요하지 않은 문제를 해결하려다가 훨씬 많은 코드를 생산할 것이다.
- 잘못된 추상화 수준은 사용자 인터페이스까지 영향을 미쳐 사용자에게 혼란을 주는 경우도 종종 발생한다.
	- 이로 인해 시간과 비용이 낭비된다.
- 프로젝트 초반에 미래의 모든 요구를 생각하고 반영할 수는 없다. 새로운 스크럼 개념들은 앞으로도 추가될 것이고, 기존 모델은 요구사항을 예견하는데 실패할 수 밖에 없기 때문이다.

이런 부적절한 추상화 수준은 기술적인 측면으로 구현을 생각하는 상황에서 자주 등장한다.

**높은 수준의 추상화 구현이라는 덫에 현혹되지 말자.** 팀이 정의한 도메인 전문가의 멘탈 모델에 따라 보편언어를 모델링해야한다.

# 올바른 크기의 애그리게잇

일관성 경계 목표에 도달하는 데 도움을 줄 아래 설계 단계들을 살펴보자.

1. 먼저 애그리게잇 설계의 두 번째 규칙인 "작은 애그리게잇을 설계하라"에 집중하자.
	- 애그리게잇 루트로 제공될 오직 1개의 엔티티만을 갖는 애그리게잇을 생성한다.
	- 각 엔티티들을 단일의 루트 엔티티와 관련이 가장 깊다고 생각되는 필드, 속성, 프로퍼티로 채우자.
	- 가장 주의할 점은 애그리게잇을 식별하고 찾는 데 필요한 모든 필드, 속성, 프로퍼티를 정의하는 것 뿐만 아니라 애그리게잇을 초기에 만들 때 유효한 초기 상태를 구성하는데 필요한 모든 추가적인 필드, 속성, 프로퍼티를 정의하는 것이다.
2. 이제 애그리게잇 설계의 첫 번째 규칙인 "애그리게잇 경계 내의 비즈니스 불변사항을 보호하라"로 관심을 돌리자.
	- 방금 전 단계에서 단일 엔티티 애그리게잇을 저장할 때, 모든 필드, 속성이 반드시 최신의 정보를 포함한 상태여야한다는 것을 알았을 것이다.
	- 하지만 지금 단계에서는 애그리게잇을 하나씩 살펴봐야 한다.
	- 애그리게잇 A1을 살펴본다 가정할 때, 이미 정의한 다른 애그리게잇들 중 A1 애그리게잇이 변경될 때, 함께 갱신되어야 하는 것이 있는지 도메인 전문가와 확인한다.
	- 애그리게잇의 행위에 관련된 모든 갱신에 걸리는 시간을 파악할 수 있는 관련된 애그리게잇들의 목록과 일관성 규칙을 만든다
		- 이것을 다시 말하면, "애그리게잇 A1"을 목록의 가장 앞에 위치시키고, A1의 변경에 따라 바뀌어야 할 다른 애그리게잇들을 그 아래에 위치시킨다.
3. 반응에 맞춘 갱신이 일어나는 시간은 얼마나 걸릴지 도메인 전문가에게 확인하자.
	- 즉시 혹은 N초/분/시간/일 과 같은 두 가지 유형의 명세로 정의될 것이다.
	- 올바른 비즈니스 임계치를 찾는 한 가지 방법은 받아들여질 수 없는 과장된 소요 시간을 먼저 제시하는 것이다.
		- 이는 비즈니스 전문가로 하여금 받아들일 수 있는 소요 시간을 답하게 만들 수 있을 것이다.
4. 각각의 애그리게잇들이 즉시 처리되어야 하는 경우, 동일한 애그리게잇 경계 안에 그 2개의 엔티티를 구성하는 것을 긍정적으로 검토해야 한다.
	- 예를 들어, 애그리게잇 A1과 A2를 "새로운 애그리게잇 A[1,2]" 로 구성한다는 것이다.
	- 이렇게 변경한다면 이전에 정의했던 애그리게잇 A1과 A2는 더 이상 존재하지 않고, 오직 애그리게잇 A[1, 2]만 존재한다.
5. 각각의 애그리게잇들이 주어진 시간에 따라 각각 반응하는 경우, 애그리게잇 설계의 네 번째 규칙인 "결과적 일관성을 사용하여 다른 애그리게잇을 갱신하라"를 사용해서 갱신한다.

![image](https://user-images.githubusercontent.com/37062337/210366507-d4d3d043-b5ee-420d-8ed9-9a409ab127c5.png)


위 그림에서 A1 관점에서의 모델링을 살펴보자. A1의 일관성 규칙 목록에는 A2가 적혀있고, C14는 소요 시간 30초를 갖는다. 결과적으로 A1, A2는 A[1, 2]하나의 애그리게잇 안으로 통합 모델링된다. 또한 런타임 중에 애그리게잇 A[1, 2]는 애그리게잇 C14를 갱신하도록 하는 도메인 이벤트를 발행시킨다.

모든 애그리게잇이 함께 즉각적인 갱신에 들어가야 한다고 비즈니스 측에서 일방적으로 주장하는지 주의를 기울여야 한다. 설계 회의에 참여하는 많은 사람들이 데이터베이스 설계와 데이터 모델링 영향을 받을 때, 특히 강하게 이런 경향을 보일 수 있다. 그 이해관계자들은 트랜잭션 위주의 관점을 가질 것이다. 하지만 실제로 비즈니스가 모든 상황에 즉각적인 일관성을 요구할 가능성은 매우 낮다.

비즈니스 측의 이런 생각을 바꾸기 위해 현재의 큰 클러스터 애그리게잇을 구성하는 여러 애그리게잇들에 걸친, 다수의 사용자들에 의해 동시에 발생하는 갱신들로 인해 어떻게 트랜잭션이 실패하게 될지 입증하는데 시간을 보내는 상황이 발생할 수 있다. 뿐만 아니라 이런 클러스터 설계로 인해 얼마나 많은 메모리 오버헤드가 발생하는지에 대해 이야기를 할 수 있다. 분명 이런 문제들은 우선적으로 피하려고 노력해야 하는 것 들이다.

이런 활동은 **비즈니스 주도**라는 것을 보여준다. 물론, 다수의 애그리게잇 사이에 갱신을 위한 기술적인 방안도 찾아야 한다. 하지만 다양한 엔티티 간 발생하는 갱신의 수용 가능한 소요 시간을 결정할 수 있는 것은 오직 비즈니스이다. 

이는 즉시 또는 적절한 트랜잭션으로 처리돼야 하는 것들은 동일한 애그리게잇으로 관리해야 한다는 의미이며, 결과적인 일관성이 필요한 경우에는 메시징과 같은 도메인 이벤트를 통해 관리해야 한다는 의미이다.

# 테스트 가능한 단위

단위 테스트를 통해 애그리게잇을 철저하게 캡슐화되도록 설계하자.

복잡한 애그리게잇은 테스트하기 어렵다. 이전의 설계 가이드들은 테스트할 수 있는 애그리게잇을 모델링할 수 있는 좋은 지침들을 제공한다. 단위 테스트를 만드는 일은 인수 테스트에 관한 시나리오 명세 만드는 과정을 따라할 것이다. 여기서 고려해야할 점은 **애그리게잇이 수행하길 기대하는 대로 정확하게 수행되는지 테스트하는 것이다.**

또한 애그리게잇의 모든 오퍼레이션이 정확성, 품질, 안정성을 보장하길 원할 것이다. 이를 위해 단위 테스트 프레임워크를 사용할 수 있고, 다른 방법들을 활용할 수 있다. 단위 테스트들은 바운디드 컨텍스트와 직접적으로 연관되는 것으로 해당 소스 코드 리파지토리에 보관될 것이다.

# 요약
- 애그리게잇 패턴이 무엇이며, 왜 이 패턴을 사용해야하는가?
- 일관성 경계를 염두에 두고 설계하는 것의 중요성
- 애그리게잇과 관련된 다양한 부분들
- 효과적인 애그리게잇 설계의 네 가지 규칙
- 애그리게잇의 고유한 식별자를 설계할 수 있는 방법
- 애그리게잇 속성의 중요성과 빈약한 도메인 모델 생성을 피하는 방법
- 애그리게잇의 행위를 모델링하는 방법
- 언제나 바운디드 컨텍스트가 보편언어를 따르도록 하기
- 설계에 적절한 추상화 수준을 선택하는 것의 중요성
- 올바른 크기의 애그리게잇 구성 기술과 테스트 가능하도록 설계하는 방법
