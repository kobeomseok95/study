```toc
```
# 서론

![image](https://user-images.githubusercontent.com/110817509/212536083-6808efb3-0d10-47bc-a2ad-24562fb113e1.png)

도메인 이벤트를 사용해 얻을 수 있는 장점을 살펴보기 위해 **인과관계 일관성**이라는 개념을 살펴보자. 비즈니스 도메인은 어떤 하나의 요청이 분산된 시스템의 모든 노드들에게 변경 여파가 발생할 경우 의존관계 일관성을 제공한다.

인과관계에 있는 오퍼레이션은 반드시 특정한 요청에 의해 발생하기 때문에 그 특정한 요청이 발생되지 않으면 인과관계에 있는 오퍼레이션은 발생할 수 없다. 

정리하자면 특정한 오퍼레이션이 다른 애그리게잇에서 명확하게 발생하기 전 까지는 인과관계에 있는 애그리게잇이 생성되거나 수정될 수 없다.

만약, 인과관계가 적절하게 맺어져 있지 않다면, 전체 도메인 상황이 잘못되거나 혼란스러워진다. 이런 인과관계는 선형의 시스템 아키텍처인 경우, 정확하게 순서가 정해진 도메인 이벤트의 생성과 활용을 통해 달성할 수 있다.

## 도메인 이벤트의 장점

전술적 설계를 통해 이벤트가 도메인 모델에 구체화되고 도메인 이벤트가 만들어진다. 이벤트가 발행되면 바운디드 컨텍스트와 다른 자원들은 이벤트를 받아 활용한다. 이는 중요한 이벤트에 관심이 있는 이벤트 리스너들에게 관련 상황의 발생을 알리는 매우 강력한 방법이다. 

# 도메인 이벤트를 설계, 구현, 사용하기

![image](https://user-images.githubusercontent.com/110817509/212536115-a84abcd8-7c77-4c32-b8ee-f1b838543d94.png)

위 코드는 모든 도메인 이벤트가 반드시 지원해야 하는 최소한의 인터페이스만 고려했다. 일반적으로 도메인 이벤트가 발생할 때의 날짜와 시각을 전달하길 원하는데, 이를 위해 `OccurredOn` 프로퍼티를 제공한다. 필요없을 수 있지만, 일반적인 도메인 이벤트를 위 인터페이스를 구현할 확률이 높다.

## 타입명을 어떻게 붙일 것인가?

도메인 이벤트에 어떻게 이름을 붙일 것인지에 대해 세심한 주의를 기울여야 한다. 여기 사용되는 단어들은 도메인 모델의 보편언어를 반영해야 한다.

도메인 이벤트 타입을 나타내는 이벤트 이름은 과거에 발생한 것을 서술하는데, 이는 과거형 동사로 표현할 수 있다. 이는 도메인 모델 안에서 발생하는 사건과 모델 밖을 이어주는 다리를 형성하는데 도움을 준다.

## 도메인 이벤트는 어떤 내용을 담고 있어야 할까?

![image](https://user-images.githubusercontent.com/110817509/212536416-e57773e4-aae8-4387-a97a-9d41a7964d7b.png)

그 전에 "애플리케이션에서 어떤 것들이 도메인 이벤트를 발생시킬까?" 에 대한 답은 "명령을 통해서"이다. 명령은 메서드나 액션을 요청하는 객체 형태를 의미한다. 위 사진에서는 `createProduct()`가 명령이고, 이 명령을 통한 결과는 `ProductCreated`라 할 수 있다.

### 도메인 이벤트 내용에 대한 사례

![image](https://user-images.githubusercontent.com/110817509/212537324-23755c4e-59c7-40b2-8b67-9baaf1a380f0.png)

ProductCreated는 이벤트가 만들어지는 시점에 명령이 제공하는 모든 프로퍼티를 담고 있어야 한다. tenantId, productId, name, description 프로퍼티를 통해 모든 이벤트 구독자들에게 모델에서 무슨일이 벌어졌는지 정확하게 알릴 수 있다.

![image](https://user-images.githubusercontent.com/110817509/212537493-69a79a14-c1fd-426c-8a65-4de11f757dce.png)

예를 들어, BacklogItem이 Sprint에 할당되면 BacklogItemCommitted 도메인 이벤트가 발행된다. 이 도메인 이벤트는 tenantId, sprintId, backlogItemId를 프로퍼티로 포함하고 있다.

## 도메인 이벤트 내용의 크기는?

도메인 이벤트가 풍부한 추가 데이터를 담고 있을 수 있다. 이는 필요한 추가 정보를 얻기 위해 추가 쿼리를 실행하고 싶지 않은 구독자들에게 도움이 된다.

하지만, 도메인 이벤트에 그 의미를 잃을 정도로 너무 많은 데이터를 가득 채우는 일이 없도록 주의해야 한다. 예를 들어, BacklogItemCommitted 도메인 이벤트 객체에 BacklogItem의 전체 상태를 담는 다면 구독자 입장에서 이해하기 어렵게 만들 수 있다. 만약, 수정 이벤트를 발행하는 BacklogItemUpdated를 만든다면 이전 / 이후 상태값을 비교해야하기 때문에 정확히 이해하기 어려울 수 있다.

## 사례

![image](https://user-images.githubusercontent.com/110817509/212537831-b663240c-df84-4803-9b51-50429b5779ac.png)

제품 책임자는 Sprint에 BacklogItem을 할당한다. 이 명령은 BacklogItem과 Sprint를 메모리에 생성시킨다. 다음 명령은 BacklogItem 애그리게잇에서 실행된다. 그 결과 BacklogItem의 상태가 수정되고, BacklogItemCommitted 이벤트가 발행된다.

![image](https://user-images.githubusercontent.com/110817509/212538008-e2908b8c-60f4-4358-a953-b84f292bc6fb.png)

수정된 애그리게잇과 도메인 이벤트는 같은 트랜잭션에서 함께 저장될 필요가 있다. 만약 ORM을 사용한다면 애그리게잇을 하나의 테이블, 도메인 이벤트는 하나의 이벤트 리파지토리 테이블에 저장하고, 트랜잭션을 설정할 수 있다. 도메인 이벤트를 이벤트 리파지토리에 유지하는 것은 도메인 모델 간에 발생한 것에 대한 인과관계의 순서를 지속시켜준다.

![image](https://user-images.githubusercontent.com/110817509/212538096-8bb9aef3-462f-45e2-9e3b-329493594b47.png)

도메인 이벤트가 이벤트 리파지토리에 저장되면, 이벤트에 관심 있는 어떤 대상에게든지 전달될 수 있다. 이는 바운디드 컨텍스트 내부 혹은 외부일 수 있다.

단, 도메인 이벤트를 인과관계의 순서에 따라 저장하는 것이 같은 요청 내 분산돼 있는 다른 노드들에 도달할 것을 보장하는 것은 아니다. 적절한 인과관계를 파악하는 것 또한 구독자 혹은 소비자 바운디드 컨텍스트의 책임이다.

도메인 이벤트 그 자체가 인과관계를 나타내거나 시퀀스나 인과관계 식별자 처럼 도메인 이벤트와 관계된 메타데이터 형태가 인과관계를 나타낼 수 있다. 인과관계 식별자는 도메인 이벤트가 발생했다는 것을 나타내줄 것이고, 아직 인과관계가 확인되지 않았다면 구독자가 도달할 이벤트를 기다려야 한다.

누가 이벤트를 발생시키는지에 대해서도 주목할 필요가 있다. 보통은 사용자 기반 명령인 경우가 많지만 때로는 다른 원인으로 도메인 이벤트가 발행될 수 있다.

예를 들면, 마지막 영업일 / 주, 년, 월의 마지막과 같은 시간 만료에 의해서도 이벤트가 발행될 수 있다. 이 경우 이벤트를 발생시키는 명령을 보내지 않는데, 이유는 시간이라는 명확한 사실이 있기 때문이다. 비즈니스가 만료 시간에 맞춰 일을 해야한다면 명령이 아닌 도메인 이벤트로 시간 만료를 모델링해야 한다.
- *회계 연도 종료*
- *장 종료*

# 이벤트 소싱

![image](https://user-images.githubusercontent.com/110817509/212538799-5df6e166-7d21-4d2c-b1e0-e97d00d39337.png)

이벤트 소싱이란, 애그리게잇 인스턴스에서 발생한 모든 도메인 이벤트를 저장하는 것을 의미한다. 즉, 애그리게잇의 최신 상태를 저장하는 것이 아닌 발생했던 도메인 이벤트 모두를 저장하는 것이다.

하나의 애그리게잇 인스턴스에 발생했던 모든 도메인 이벤트를 발생한 순서대로 이벤트 스트림에 구성한다. 이벤트 스트림은 애그리게잇에 가장 처음 발생했던 도메인 이벤트로 시작하여 마지막 도메인 이벤트까지 계속된다. 만약 애그리게잇에 이벤트 스트림을 재적용하면 삭제되었던 애그리게잇들을 이벤트 스트림을 통해 온전히 환원시킬 수 있다.

위 다이어그램에서는 하나의 애그리게잇이 수정될 때 세 가지의 이벤트가 발생하는데, 이를 이벤트 저장소에 저장하는 것이다.

![image](https://user-images.githubusercontent.com/110817509/212538566-5fda3217-1f8d-4ed3-b5fa-8faaec494749.png)

이벤트 리파지토리는 모든 도메인 이벤트를 추가하는 순차적인 리파지토리 컬렉션 또는 테이블을 의미한다. 이벤트 스토어는 추가만 가능한데, 이런 특성으로 인해 리파지토리 메커니즘은 매우 빠르게 동작한다. 그래서 매우 높은 처리량, 낮은 대기 시간, 높은 확장성을 위해 이벤트 소싱을 사용하는 핵심 도메인을 만들 수 있다.

## 성능 고려

만약 주요 관심사 중 하나가 성능이라면 캐싱과 스냅샷에 대해 알고 있는 것이 좋다.
- 가장 높은 성능을 요구하는 애그리게잇을 메모리에 캐시한다.
	- 이렇게 되면 리파지토리에서 다시 불러올 이유가 없다.
- 스냅샷은 이벤트 스트림으로부터 모든 도메인 이벤트를 다시 부르지 않고 메모리에서 사라진 애그리게잇을 다시 메모리로 부르는 시간을 최적화할 수 있다.

## 이벤트 소싱의 이점

이벤트 소싱은 핵심 도메인에서 계속 발생하는 모든 기록을 개별적인 발생 수준으로 저장한다는 점이다. 이는 비즈니스와 기술적으로 큰 이점을 가져다 준다. 기술적인 이점의 경우 개발자가 소스 코드를 디버깅하거나 이벤트 사용 추세를 조사할 때, 이벤트 스트림을 사용해볼 수 있다.
