```toc
```

# 개요

![image](https://user-images.githubusercontent.com/37062337/235460213-b8159d02-1f86-4392-ba03-2640e91c1985.png)

위의 웹 계층에서 요청을 받고 도메인 혹은 서비스로 요청을 보내, 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출한다.

이러한 계층은 코드에 나쁜 습관들이 스며들기 쉽게 만들고, 소프트웨어를 점점 더 변경하기 어렵게 만드는 허점들을 노출한다.

# 문제점 1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

보통 애플리케이션은 우리 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어 편리하게 활용할 수 있게 한다. 이 때, 우리는 상태가 아닌 행동을 중심으로 모델링한다. 행동이 상태를 변경하는 모체이기 때문에 행동이 곧 비즈니스를 이끌어 간다.

위의 그림에서는 결국 Web -> Domain(Service) -> Persistence 계층 순서로 의존하기 때문에 자연스럽게 데이터베이스에 의존하게 된다. 이는 DB 구조를 먼저 생각하고 영속성 계층을 먼저 생각 후 도메인 로직을 구현하게 한다.

또한, ORM 프레임워크를 사용하기에 위 방법은 더욱 계층형 아키텍처에서는 합리적인 방법이다. 하지만 이러한 방식은 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

![image](https://user-images.githubusercontent.com/37062337/235461917-c0bbf086-996d-40b1-8b99-c11ce4756533.png)

그림과 같은 구조가 되면, 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다. 서비스는 엔티티를 비즈니스 모델처럼 사용하게 되고, 도메인 로직 뿐만 아니라 즉시로딩, 지연로딩, 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만 한다.

즉, 영속성 코드가 사실상 도메인 코드에 녹아들어있어 둘 중 하나만 바꾸는 것이 어려워지는 상황이 발생한다. 이는 곧 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.

# 문제점 2. 지름길을 택하기 쉬워진다.

계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에서는 같은 계층에 있는 컴포넌트나 하위 계층에만 접근 가능하다는 것이다.

깨진 창문 이론에 의해 만약 상위 계층의 컴포넌트에 접근해야하고, 이 상위 컴포넌트를 누군가가 아래로 내려버렸다면, 다른 개발자도 이처럼 하위 컴포넌트로 내려버리기 십상이다. 이는 곧 계층형 아키텍처의 하위 컴포넌트인 영속성 계층이 비대해진다.

# 문제점 3. 테스트하기 어려워진다.

계층형 아키텍처 사용 시, 일반적으로 나타나는 변화의 형태는 게층을 건너뛰는 것이다.

![image](https://user-images.githubusercontent.com/37062337/235463669-ca31eaa3-8ea7-4f02-ab16-10bdcda5f59e.png)

앞의 깨진 창문 이론처럼 위 그림과 같은 상황이 계속 발생하게 된다면, 두 가지 문제점이 생긴다.

- 단 하나의 필드를 조작하는 것에 불과하더라도, 도메인 로직을 웹 계층에 구현하게 되는 것
	- 이는 핵심 도메인 로직이 여러 곳으로 퍼지게 된다.
- 웹 계층 테스트에서 도메인 테스트 뿐만 아니라, 영속성 계층도 모킹하는 것
	- 테스트의 복잡도를 높여, 테스트 코드의 종속성을 이해하고 mock을 만드는 데 시간이 더 걸리게 된다.

# 문제점 4. 유스케이스를 숨긴다.

계층형 아키텍처는 기능을 추가하거나, 변경할 적절한 위치를 빠르게 탐색하는 것을 방해한다.

예를 들면, 유스케이스가 간단하여 도메인 계층을 생략하거나, 도메인 계층 및 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 영속성 계층에 존재할 수 있다.

심지어 계층형 아키텍처에서는 도메인 서비스의 너비에 대한 규칙을 강제하지 않는다. 시간이 지나면 아래 그림처럼 비대한 서비스가 만들어지기도 한다.

![image](https://user-images.githubusercontent.com/37062337/235465355-c7ac27e7-aa85-4666-a6fc-95bb44fff501.png)

이러한 구조가 되면, 서비스를 테스트하기 어려워지고, 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

만약, 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나 씩만 담당하게 된다면 이런 작업들이 상당히 수월해진다. 예를 들어, UserService에서 사용자 등록 유스케이스를 찾는 대신, RegisterUserService를 바로 열어서 작업을 시작하는 것 처럼

# 문제점 5. 동시 작업이 어려워진다.

인원이 새로 투입된다고 작업 속도가 빨라지진 않는다. 대부분의 경우에는 서로 도움을 주고 받으며 개발을 진행한다. 

결국 여러 개발자가 도움을 받으며 동시에 작업을 진행해야 하는데, 계층형 아키텍처는 이런 측면에서는 도움이 되지 않는다.

예를 들어, 개발자 3명이 새로운 유스케이스를 추가한다고 가정했을 때, 계층형 아키텍처일 경우 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층 -> 도메인 계층 -> 웹 계층 순서로 작업할 것이고 이는 한 명의 개발자만 작업이 가능하게 한다.
