```toc
```
# 개요

단일 책임 원칙(Single Responsibility Principle)과 의존성 역전 원칙(Dependency Inversion Principle)에 대해 언급

# 단일 책임 원칙

보통 '하나의 컴포넌트는 한 가지 일만 해야하고, 그것을 올바르게 수행한다.' 라고 정의되어있으나, 실제 정의는 아래와 같다.

> '컴포넌트를 변경하는 이유는 오직 한 가지 이유여야만 한다.'

이것은 아키텍처 관점에서 컴포넌트를 변경할 이유가 한 가지라면, 다른 이유로 변경하더라도 해당 컴포넌트는 전혀 신경 쓸 필요가 없다. 왜냐하면, 소프트웨어가 변경되더라도 기대한 대로 동작하기 때문이다.

하지만, 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 쉽게 전파된다.

<img width="407" alt="image" src="https://user-images.githubusercontent.com/37062337/235903639-ed325310-d25d-47ab-ada8-f2fcac756840.png">

위 그림에서 A 컴포넌트는 모든 컴포넌트에 의존(직 간접 모두)한다면, E 컴포넌트는 아무것도 의존하지 않는다.

컴포넌트 E를 변경해야하는 유일한 이유는 E와 관련된 기능에 대한 변경사항이 있을 뿐이다. 하지만 A는 모든 컴포넌트에 의존하기 때문에 나머지 컴포넌트가 바뀐다면 같이 A도 바뀌어야 한다.

A 컴포넌트는 E 컴포넌트에 비해 변경할 이유가 많다는 것이고, 후에 A 컴포넌트가 의존하고 있는 컴포넌트가 바뀐다면 A 컴포넌트가 실패하는 원인이 될 수 있다.

# 의존성 역전 원칙

계층형 아키텍처에서 계층간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할 때, 상위 계층들이 하위 계층에 비해 변경할 이유가 더 많다는 것을 알 수 있다.

도메인 계층이 영속성 계층에 의존하므로, 영속성 계층을 변경할 때 마다 잠재적으로 도메인 계층도 변경해야한다. 하지만, 도메인 코드는 애플리케이션에서 가장 중요한 코드이므로, 바꾸기 까다롭다.

이러한 의존성을 의존성 역전 원칙을 통해 해결할 수 있다.

<img width="521" alt="image" src="https://user-images.githubusercontent.com/37062337/235907061-9863d66f-380b-4fa6-99e9-27de667d04bf.png">

엔티티는 도메인 객체로 표현하고, 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 한다. 그래서 엔티티를 도메인 계층으로 올린다.

엔티티를 도메인 계층으로 올렸다면 영속성 계층에 위치한 리포지토리가 도메인 계층의 엔티티에 의존하기 때문에 순환 의존성이 생긴다. 이 부분을 DIP를 적용하는 부분이다.

도메인 계층에 리포지토리 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다.

# 클린 아키텍처

클린 아키텍처에서는 설계를 다음과 같이 정의한다.

> '설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다.'

이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하도록 한다.

<img width="487" alt="image" src="https://user-images.githubusercontent.com/37062337/235909468-666f8b37-4b2d-4d11-b14b-48b5970227f2.png">

위 아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스(== 서비스)는 단일 책임을 갖기 위해 조금 더 세분화 되어 있다. 이를 통해 넓은 서비스 문제를 피할 수 있다.

이 코어 주변으로 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 컴포넌트들을 확인할 수 있다. 여기서 '지원'의 의미는 영속성, UI를 제공하는 것을 의미한다. 또한 바깥쪽 계층들은 다른 서드파티 컴포넌트에 어댑터를 제공할 수 있다.

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없다. 이로 인해 프레임워크에 특화된 코드를 가질 수 없고, 영속성 혹은 UI에 특화된 문제를 신경쓰지 않아도 되기 때문에, 비즈니스 규칙에 집중할 수 있다.

하지만 도메인 계층이 영속성이나 UI와 같은 외부 계층과 철저히 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

## 예시 - ORM

영속성 계층에서 ORM 프레임워크를 사용한다고 가정하자. ORM 프레임워크는 DB 구조 및 객체 필드와 데이터베이스 컬럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다.

도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 사용할 수 없고 별도로 계층마다 엔티티 클래스를 만들어야 한다. 즉, 두 엔티티를 서로 변환해야 한다.

하지만 이것은 바람직한 일이다. 이 부분이 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던 **결합이 제거된 상황**이다.

가령 JPA에서는 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제한다. 이 부분이 도메인 모델에서는 포함되서는 안될 프레임워크에 특화된 결합의 예시이다.

# 육각형(헥사고날) 아키텍처

<img width="827" alt="image" src="https://user-images.githubusercontent.com/37062337/235914622-47b1a17f-7a27-480e-9d6d-21d7493f7106.png">

육각형 도형 내부에는 도메인 엔티티와 상호작용하는 유스케이스가 있다. 육각형 내에서 외부로 향하는 의존성이 없기 때문에 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된 점을 주목하자. 대신, 모든 의존성은 코어를 향한다.

육각형 밖에는 상호작용하는 다양한 어댑터(웹, 외부 시스템 어댑터, 데이터베이스)들이 있다. 그림의 왼쪽에는 코어를 호출하므로, 애플리케이션을 주도하는 어댑터들이다. 오른쪽은 애플리케이션 코어에 의해 호출되는 즉, 애플리케이션에 주도되는 어댑터들이다.

코어와 어댑터들 간의 통신이 가능하게 하려면, 애플리케이션 코어가 각각의 포트를 제공해야 한다. 주도하는 어댑터들의 포트는 코어에 있는 유스케이스 클래스들에 의해 구현되며, 호출되는 인터페이스가 될 것이다. 반대로 주도되는 어댑터들의 포트는 어댑터에 의해 구현되고, 코어에 의해 호출되는 인터페이스가 될 것이다.
